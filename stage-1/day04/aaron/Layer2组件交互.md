## 流程设计
### ETH Optimistic Rollup（Layer2）工作流程           
                 步骤1：用户将资产从Layer1跨到Layer2（“上桥”） 
                                                                        
  1. 用户在 ETH 主链（Layer1）将 ETH/ERC20 资产转入 Rollup 智能合约（“桥合约”）；
  2. 合约锁定用户资产后，向 Layer2 网络发送“资产到账通知”；               
  3. Layer2 网络为用户创建对应的账户，存入等额锚定资产（如 Layer2 ETH = 主链 ETH）；
                                                                         
───────────── → 主链记录“资产锁定”，Layer2 生成对应资产 ←────────────

                 步骤2：Layer2 批量处理交易（“链下计算+打包”）
                                                                        
  1. 大量用户在 Layer2 上进行交易（如 DeFi 兑换、NFT 购买）；             
  2. Layer2 节点（Sequencer）实时处理这些交易，执行智能合约逻辑（链下计算）； 
  3. 节点将多笔交易（如 1000 笔）打包成一个“交易批次”，计算出该批次的“状态根”（即交易后所有账户的余额摘要）； 
                                                                         
───────────── → 1000 笔交易仅生成一个“状态根”，数据量压缩 90%+ ←────────────

                 步骤3：向Layer1提交交易数据+状态根（“提交结果”）
                                                                         
  1. Layer2 节点将压缩后的交易数据（仅关键信息）和状态根，提交到 ETH 主链的 Rollup 合约； 
  2. 主链不实时验证每笔交易（Optimistic = “乐观假设交易合法”），仅存储数据和状态根； 
  3. 进入“挑战期”（如 7 天），期间任何节点可质疑交易合法性（若发现恶意交易，可提交证据反驳）。 
                                                                         
───────────── → 主链仅存储压缩数据，不消耗大量区块空间 ←────────────

                  步骤4：挑战期结束，结果上链生效（“最终结算”）
                                                                         
  1. 若挑战期内无有效质疑，主链确认 Layer2 提交的状态根合法；             
  2. 主链更新 Rollup 合约的状态，完成最终结算；                           
  3. 用户若想将资产转回 Layer1，可发起“下桥”请求，主链解锁对应资产并转账。 
                                                                         
───────────── → 主链保障最终结果不可篡改，Layer2 负责高效处理 ←────────────

### ETH ZK Rollup(layer2)工作流程
               步骤1：上桥
                                       
  1. 用户A在ETH主链发起“上桥交易”，将100 USDC转入ZK Rollup智能合约； 
  2. 主链合约锁定A的100 USDC，同时记录“A上桥100 USDC”的信息；     
  3. 合约向ZK Rollup网络发送“到账通知”；                           
  4. ZK Rollup为A创建L2账户，存入100 “L2 USDC”（与主链USDC 1:1锚定）； 
                                       │
───────────── → 主链仅记录“锁定资产”，L2生成可交易的锚定资产 ←────────────

                步骤2：收集+打包 
                                           
  1. 用户A在L2发起交易：给用户B转10 L2 USDC（签名后发送）；       
  2. Relayer 持续收集全网L2交易（包括A→B的交易，共1000笔）；     
  3. Relayer 初步校验：交易签名是否有效、用户余额是否充足（A有100≥10）； 
  4. 将1000笔有效交易打包成一个“交易批次”；                       
                                           │
───────────── → 1000笔交易仅打包成1个批次，减少主链数据量 ←────────────
              步骤3：执行+生成ZK证明
                                                
  1. Relayer 在链下执行“交易批次包”内的1000笔交易： 
     - A的L2余额：100 → 90 USDC；                
     - B的L2余额：50 → 60 USDC；                 
     - 其他998笔交易同步更新对应账户状态；        
  2. 生成“状态根”：                               
     - 用默克尔树记录所有L2账户状态（叶子=单个账户，树根=全局状态）； 
     - 交易前的全局状态 → 初始状态根（S1）；        
     - 交易后的全局状态 → 最终状态根（S2）；        
  3. 生成零知识证明（ZK-Proof）：                  
     - 基于“交易数据+S1+S2”，用zk-SNARK/zk-STARK技术构建证明；   
     - 证明结论：“这1000笔交易执行正确，S1能合法迁移到S2”；       
     - 证明不泄露任何单笔交易细节（如A转了多少、转给谁）；        
                                                
───────────── → 链下完成所有计算，仅输出“证明+状态根” ←────────────
              步骤4：提交+验证 
                                           
  1. Relayer 将3类数据提交到主链ZK Rollup合约： 
     - 压缩后的交易数据（仅摘要，1000笔→几百KB）； 
     - 初始状态根S1、最终状态根S2；             
     - 零知识证明ZK-Proof；                     
  2. 主链合约不校验任何单笔交易，仅做1件事：     
     - 验证ZK-Proof是否有效（耗时毫秒级，因为证明仅几百字节）； 
  3. 验证结果：                                 
     - 有效 → 认可交易批次合法；                
     - 无效 → 直接拒绝该批次，数据不上链；       
                                           
───────────── → 主链仅做“证明验证”，效率极高 ←────────────

               步骤5：更新状态+下桥 
  1. 验证有效后，主链合约更新全局状态：将S1替换为S2，记录压缩交易数据（供后续审计）； 
  2. 若用户B想把L2资产转回主链（下桥）：         
     - B在L2发起“下桥请求”，Relayer协助提交到主链合约； 
     - 合约验证B的L2余额（60 USDC），解锁对应数量的主链USDC； 
     - 主链向B的Layer1地址转账60 USDC，下桥完成；   
                                              
───────────── → 主链仅记录最终状态，下桥无需等待 ←────────────